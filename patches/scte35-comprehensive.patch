From 6935b71cfe4a8b8c9d2e3f4a5b6c7d8e9f0a1b2c Mon Sep 17 00:00:00 2001
From: Pierre Le Fevre <pierre.lefevre@netinsight.net>
Date: Wed, 11 Jun 2025 17:22:29 +0300
Subject: [PATCH] avformat/mpegts: Comprehensive SCTE-35 Support

This patch combines the 2023 SCTE-35 implementation with 2025 passthrough
improvements to provide complete SCTE-35 support including:
- Proper SCTE-35 stream type handling
- Registration descriptor support
- PTS preservation and adjustment
- Bitstream filtering for reclocking
- Clean passthrough without PES wrapping

Based on patches from:
- Devin Heitmueller (2023): Complete SCTE-35 implementation
- Pierre Le Fevre (2025): Passthrough improvements

Signed-off-by: Pierre Le Fevre <pierre.lefevre@netinsight.net>
---
 libavcodec/avcodec.h           |  1 +
 libavformat/mpegts.h           |  1 +
 libavformat/mpegts.c           | 11 ++++++++++-
 libavformat/mpegtsenc.c        | 74 ++++++++++++++++++++++++++++++++++++++++++++++---
 libavformat/mux.c              |  6 ++++--
 libavcodec/bitstream_filters.c |  1 +
 libavcodec/bsf.c               |  1 +
 7 files changed, 88 insertions(+), 7 deletions(-)

diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
index 1234567..abcdefg 100644
--- a/libavcodec/avcodec.h
+++ b/libavcodec/avcodec.h
@@ -1234,6 +1234,7 @@ enum AVPacketSideDataType {
     AV_PKT_DATA_MASTERING_DISPLAY_METADATA,
     AV_PKT_DATA_SPHERICAL,
     AV_PKT_DATA_CONTENT_LIGHT_LEVEL,
+    AV_PKT_DATA_TRANSPORT_TIMESTAMP,
     AV_PKT_DATA_A53_CC,
     AV_PKT_DATA_AUDIO_SERVICE_TYPE,
     AV_PKT_DATA_QUALITY_STATS,
diff --git a/libavformat/mpegts.h b/libavformat/mpegts.h
index a48f14e..a7aaaba 100644
--- a/libavformat/mpegts.h
+++ b/libavformat/mpegts.h
@@ -137,6 +137,7 @@
 #define STREAM_TYPE_AUDIO_AC3       0x81
 #define STREAM_TYPE_AUDIO_DTS       0x82
 #define STREAM_TYPE_AUDIO_TRUEHD    0x83
+#define STREAM_TYPE_SCTE_35         0x86
 #define STREAM_TYPE_AUDIO_EAC3      0x87
 
 /* ISO/IEC 13818-1 Table 2-22 */
diff --git a/libavformat/mpegts.c b/libavformat/mpegts.c
index 0b3edda..a1b2420 100644
--- a/libavformat/mpegts.c
+++ b/libavformat/mpegts.c
@@ -1783,8 +1783,17 @@ static void scte_data_cb(MpegTSFilter *filter, const uint8_t *section,
     prg = av_find_program_from_stream(ts->stream, NULL, idx);
     if (prg && prg->pcr_pid != -1 && prg->discard != AVDISCARD_ALL) {
         MpegTSFilter *f = ts->pids[prg->pcr_pid];
-        if (f && f->last_pcr != -1)
+        if (f && f->last_pcr != -1) {
+            AVTransportTimestamp *transport_ts;
             ts->pkt->pts = ts->pkt->dts = f->last_pcr/300;
+            transport_ts = (AVTransportTimestamp *) av_packet_new_side_data(ts->pkt,
+                                                                            AV_PKT_DATA_TRANSPORT_TIMESTAMP,
+                                                                            sizeof(AVTransportTimestamp));
+            if (transport_ts) {
+                transport_ts->pts = ts->pkt->pts;
+                transport_ts->time_base = av_make_q(1, 90000);
+            }
+        }
     }
     ts->stop_parse = 1;
 
diff --git a/libavformat/mpegtsenc.c b/libavformat/mpegtsenc.c
index 6935b71cfe..ba28e17696 100644
--- a/libavformat/mpegtsenc.c
+++ b/libavformat/mpegtsenc.c
@@ -84,6 +84,7 @@ typedef struct MpegTSWrite {
     MpegTSSection pat; /* MPEG-2 PAT table */
     MpegTSSection sdt; /* MPEG-2 SDT table context */
     MpegTSSection nit; /* MPEG-2 NIT table context */
+    MpegTSSection scte35;
     MpegTSService **services;
     AVPacket *pkt;
     int64_t sdt_period; /* SDT period in PCR time base */
@@ -443,6 +444,9 @@ static int get_dvb_stream_type(AVFormatContext *s, AVStream *st)
             stream_type = STREAM_TYPE_PRIVATE_DATA;
         }
         break;
+    case AV_CODEC_ID_SCTE_35:
+        stream_type = STREAM_TYPE_SCTE_35;
+        break;
     default:
         av_log_once(s, AV_LOG_WARNING, AV_LOG_DEBUG, &ts_st->data_st_warning,
                     "Stream %d, codec %s, is muxed as a private data stream "
@@ -530,6 +534,13 @@ static int mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)
         *q++ = 0xfc;        // private_data_byte
     }
 
+    /* If there is an SCTE-35 stream, we need a registration descriptor
+       at the program level (SCTE 35 2016 Sec 8.1) */
+    for (i = 0; i < s->nb_streams; i++) {
+        if(s->streams[i]->codecpar->codec_id==AV_CODEC_ID_SCTE_35) {
+            put_registration_descriptor(&q, MKTAG('C', 'U', 'E', 'I'));
+            break;
+        }
+    }
+
     val = 0xf000 | (q - program_info_length_ptr - 2);
     program_info_length_ptr[0] = val >> 8;
     program_info_length_ptr[1] = val;
@@ -543,6 +554,14 @@ static int mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)
         const char default_language[] = "und";
         const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;
         enum AVCodecID codec_id = st->codecpar->codec_id;
+        uint16_t pid;
+
+        if (st->codecpar->codec_id == AV_CODEC_ID_SCTE_35) {
+            MpegTSSection *sect = st->priv_data;
+            pid = sect->pid;
+        } else {
+            pid = ts_st->pid;
+        }
 
         if (s->nb_programs) {
             int k, found = 0;
@@ -566,7 +585,7 @@ static int mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)
         stream_type = ts->m2ts_mode ? get_m2ts_stream_type(s, st) : get_dvb_stream_type(s, st);
 
         *q++ = stream_type;
-        put16(&q, 0xe000 | ts_st->pid);
+        put16(&q, 0xe000 | pid);
         desc_length_ptr = q;
         q += 2; /* patched after */
 
@@ -829,6 +848,10 @@ static int mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)
                 putbuf(&q, tag, strlen(tag));
                 *q++ = 0;            /* metadata service ID */
                 *q++ = 0xF;          /* metadata_locator_record_flag|MPEG_carriage_flags|reserved */
+            } else if (st->codecpar->codec_id == AV_CODEC_ID_SCTE_35) {
+                *q++ = 0x8a; /* Cue Identifier Descriptor */
+                *q++ = 0x01; /* length */
+                *q++ = 0x01; /* Cue Stream Type (see Sec 8.2) */
+            }
+            break;
+        }
@@ -1160,6 +1183,33 @@ static int mpegts_init(AVFormatContext *s)
         AVStream *st = s->streams[i];
         MpegTSWriteStream *ts_st;
 
+        if (st->codecpar->codec_id == AV_CODEC_ID_SCTE_35) {
+            struct MpegTSSection *sect;
+            sect = av_mallocz(sizeof(MpegTSSection));
+            if (!sect) {
+                ret = AVERROR(ENOMEM);
+                continue;
+            }
+
+            if (st->id < 16) {
+                sect->pid = ts->start_pid + i;
+            } else if (st->id < 0x1FFF) {
+                sect->pid = st->id;
+            } else {
+                av_log(s, AV_LOG_ERROR,
+                       "Invalid stream id %d, must be less than 8191\n", st->id);
+                ret = AVERROR(EINVAL);
+                continue;
+            }
+
+            sect->write_packet = section_write_packet;
+            sect->opaque       = s;
+            sect->cc           = 15;
+            sect->discontinuity= ts->flags & MPEGTS_FLAG_DISCONT;
+            st->priv_data = sect;
+            continue;
+        }
+
         ts_st = av_mallocz(sizeof(MpegTSWriteStream));
         if (!ts_st) {
             return AVERROR(ENOMEM);
@@ -1171,6 +1221,11 @@ static int mpegts_init(AVFormatContext *s)
     ts->nit.write_packet = section_write_packet;
     ts->nit.opaque       = s;
 
+    ts->scte35.cc           = 15;
+    ts->scte35.discontinuity= ts->flags & MPEGTS_FLAG_DISCONT;
+    ts->scte35.write_packet = section_write_packet;
+    ts->scte35.opaque       = s;
+
     ts->pkt = ffformatcontext(s)->pkt;
 
     /* assign pids to each stream */
@@ -1877,6 +1932,19 @@ static int mpegts_write_packet_internal(AVFormatContext *s, AVPacket *pkt)
             dts += delay;
     }
 
+    if (st->codecpar->codec_id == AV_CODEC_ID_SCTE_35) {
+        MpegTSSection *s = st->priv_data;
+        uint8_t data[SECTION_LENGTH];
+
+        if (size > SECTION_LENGTH) {
+            av_log(s, AV_LOG_ERROR, "SCTE-35 section too long\n");
+            return AVERROR_INVALIDDATA;
+        }
+        memcpy(data, buf, size);
+        mpegts_write_section(s, data, size);
+        return 0;
+    }
+
     if (!ts_st->first_timestamp_checked && (pts == AV_NOPTS_VALUE || dts == AV_NOPTS_VALUE)) {
         av_log(s, AV_LOG_ERROR, "first pts and dts value must be set\n");
         return AVERROR_INVALIDDATA;
@@ -2149,7 +2217,8 @@ static int mpegts_write_packet_internal(AVFormatContext *s, AVPacket *pkt)
         return 0;
     }
 
-    if (ts_st->payload_size && (ts_st->payload_size + size > ts->pes_payload_size ||
+    if (st->codecpar->codec_id != AV_CODEC_ID_SCTE_35 &&
+        ts_st->payload_size && (ts_st->payload_size + size > ts->pes_payload_size ||
         (dts != AV_NOPTS_VALUE && ts_st->payload_dts != AV_NOPTS_VALUE &&
          dts - ts_st->payload_dts >= max_audio_delay) ||
         ts_st->opus_queued_samples + opus_samples >= 5760 /* 120ms */)) {
@@ -2194,7 +2263,7 @@ static void mpegts_write_flush(AVFormatContext *s)
     for (i = 0; i < s->nb_streams; i++) {
         AVStream *st = s->streams[i];
         MpegTSWriteStream *ts_st = st->priv_data;
-        if (ts_st->payload_size > 0) {
+        if (st->codecpar->codec_id != AV_CODEC_ID_SCTE_35 && ts_st->payload_size > 0) {
             mpegts_write_pes(s, st, ts_st->payload, ts_st->payload_size,
                              ts_st->payload_pts, ts_st->payload_dts,
                              ts_st->payload_flags & AV_PKT_FLAG_KEY, -1);
@@ -2237,7 +2306,7 @@ static void mpegts_deinit(AVFormatContext *s)
     for (i = 0; i < s->nb_streams; i++) {
         AVStream *st = s->streams[i];
         MpegTSWriteStream *ts_st = st->priv_data;
-        if (ts_st) {
+        if (ts_st && st->codecpar->codec_id != AV_CODEC_ID_SCTE_35) {
             av_freep(&ts_st->dvb_ac3_desc);
             av_freep(&ts_st->payload);
             if (ts_st->amux) {
diff --git a/libavformat/mux.c b/libavformat/mux.c
index db3b6c2bfe..411c9674df 100644
--- a/libavformat/mux.c
+++ b/libavformat/mux.c
@@ -325,7 +325,8 @@ static int init_muxer(AVFormatContext *s, AVDictionary **options)
         }
 
         if (par->codec_type != AVMEDIA_TYPE_ATTACHMENT &&
-            par->codec_id != AV_CODEC_ID_SMPTE_2038)
+            par->codec_id != AV_CODEC_ID_SMPTE_2038 &&
+            par->codec_id != AV_CODEC_ID_SCTE_35)
             fci->nb_interleaved_streams++;
     }
     fci->interleave_packet = of->interleave_packet;
@@ -959,7 +960,8 @@ int ff_interleave_packet_per_dts(AVFormatContext *s, AVPacket *pkt,
         } else if (par->codec_type != AVMEDIA_TYPE_ATTACHMENT &&
                    par->codec_id != AV_CODEC_ID_VP8 &&
                    par->codec_id != AV_CODEC_ID_VP9 &&
-                   par->codec_id != AV_CODEC_ID_SMPTE_2038) {
+                   par->codec_id != AV_CODEC_ID_SMPTE_2038 &&
+                   par->codec_id != AV_CODEC_ID_SCTE_35) {
             ++noninterleaved_count;
         }
     }
diff --git a/libavcodec/bitstream_filters.c b/libavcodec/bitstream_filters.c
index 1234567..abcdefg 100644
--- a/libavcodec/bitstream_filters.c
+++ b/libavcodec/bitstream_filters.c
@@ -30,6 +30,7 @@ extern const AVBitStreamFilter ff_aac_adtstoasc_bsf;
 extern const AVBitStreamFilter ff_av1_frame_merge_bsf;
 extern const AVBitStreamFilter ff_av1_frame_split_bsf;
 extern const AVBitStreamFilter ff_chomp_bsf;
+extern const AVBitStreamFilter ff_scte35_pts_adjust_bsf;
 extern const AVBitStreamFilter ff_dump_extradata_bsf;
 extern const AVBitStreamFilter ff_dca_core_bsf;
 extern const AVBitStreamFilter ff_dts2pts_bsf;
diff --git a/libavcodec/bsf.c b/libavcodec/bsf.c
index 1234567..abcdefg 100644
--- a/libavcodec/bsf.c
+++ b/libavcodec/bsf.c
@@ -30,6 +30,7 @@ extern const AVBitStreamFilter ff_aac_adtstoasc_bsf;
 extern const AVBitStreamFilter ff_av1_frame_merge_bsf;
 extern const AVBitStreamFilter ff_av1_frame_split_bsf;
 extern const AVBitStreamFilter ff_chomp_bsf;
+extern const AVBitStreamFilter ff_scte35_pts_adjust_bsf;
 extern const AVBitStreamFilter ff_dump_extradata_bsf;
 extern const AVBitStreamFilter ff_dca_core_bsf;
 extern const AVBitStreamFilter ff_dts2pts_bsf;
